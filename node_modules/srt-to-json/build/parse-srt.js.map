{"version":3,"file":null,"sources":["../src/parse-srt.js"],"sourcesContent":["'use strict'\n\n/**\n * @name parseSRT\n * @desc Parses and converts SRT subtitle data into JSON format. Adapted from the popcorn.js SRT parser plugin.\n * @see http://github.com/NewtopiaDEV\n * @author Newtopia Dev (http://www.newtopia.com)\n * @version 1.0.1\n * @license MIT\n */\n\n/**\n * @typedef {JSONSubtitle}\n * @property {Number} id - The subtitle ID number.\n * @property {Number} start - The start timestamp in seconds.\n * @property {Number} end - The end timestamp in seconds.\n * @property {String} text - The subtitle HTML.\n */\n\n/**\n * @typedef {Options}\n * @property {Boolean} timeInText - Leave timestamp in text format.\n * @property {String=} propName.start - Prop name in response object for start.\n * @property {String=} propName.end - Prop name in response object for end.\n * @property {String=} propName.text - Prop name in response object for text.\n */\n\n/**\n * Convert a HH:MM:SS,MMM or HH:MM:SS.MMM time format into seconds.\n *\n * @private\n * @param {String} time - The time to be converted.\n * @return {Number} - The time converted to seconds.\n */\nfunction toSeconds (time) {\n  const t = time.split(':')\n\n  try {\n    let s = t[2].split(',')\n\n    // Just in case a . is decimal seperator\n    if (s.length === 1) {\n      s = t[2].split('.')\n    }\n\n    return parseFloat(t[0], 10) * 3600 + parseFloat(t[1], 10) * 60 + parseFloat(s[0], 10) + parseFloat(s[1], 10) / 1000\n  } catch (e) {\n    return 0\n  }\n}\n\n/**\n * Get the next non empty line number.\n *\n * @private\n * @param {Array<String>} linesArray - All the lines.\n * @param {Number} position - The current line number.\n * @return {Number} - The number of the next non empty line.\n */\nfunction nextNonEmptyLine (linesArray, position) {\n  let idx = position\n\n  while (!linesArray[idx]) {\n    idx++\n  }\n\n  return idx\n}\n\n/**\n * Get the last non empty line number.\n *\n * @private\n * @param  {Array<String>} linesArray - All the lines.\n * @return {Number} - The number of the last non empty line.\n */\nfunction lastNonEmptyLine (linesArray) {\n  let idx = linesArray.length - 1\n\n  while (idx >= 0 && !linesArray[idx]) {\n    idx--\n  }\n\n  return idx\n}\n\n/**\n * Parses and converts SRT subtitle data into JSON format.\n *\n * @public\n * @param {String} data - The SRT file contents.\n * @param {Object} options - Options for the conversion.\n * @return {Array<JSONSubtitle>} - The subtitles in a JSON format.\n *\n * @example\n * var data = `1\n * 00:00:25,712 --> 00:00:30.399\n * This text is <font color=\"red\">RED</font> and has not been {\\pos(142,120)} positioned.\n * This takes \\Nup three \\nentire lines.\n * This contains nested <b>bold, <i>italic, <u>underline</u> and <s>strike-through</s></u></i></b> HTML tags\n * Unclosed but <b>supported tags are left in\n * <ggg>Unsupported</ggg> HTML tags are left in, even if <hhh>not closed.\n * SSA tags with {\\i1} would open and close italicize {\\i0}, but are stripped\n * Multiple {\\pos(142,120)\\b1}SSA tags are stripped`\n *\n * var subtitles = parseSRT(data)\n */\nexport default function parseSRT (data = '', options = { propName: {} }) {\n  // declare needed variables and constants\n  const subs = []\n  const lines = data.split(/(?:\\r\\n|\\r|\\n)/gm)\n  let endIdx = lastNonEmptyLine(lines) + 1\n  let idx = 0\n  let time\n  let text\n  let sub\n\n  for (let i = 0; i < endIdx; i++) {\n    sub = {}\n    text = []\n\n    i = nextNonEmptyLine(lines, i)\n    sub.id = parseInt(lines[i++], 10)\n\n    // Split on '-->' delimiter, trimming spaces as well\n    time = lines[i++].split(/[\\t ]*-->[\\t ]*/)\n\n    sub[options.propName.start || 'start'] = options.timeInText ? time[0] : toSeconds(time[0])\n\n    // So as to trim positioning information from end\n    idx = time[1].indexOf(' ')\n    if (idx !== -1) {\n      time[1] = time[1].substr(0, idx)\n    }\n    sub[options.propName.end || 'end'] = options.timeInText ? time[1] : toSeconds(time[1])\n\n    // Build single line of text from multi-line subtitle in file\n    while (i < endIdx && lines[i]) {\n      text.push(lines[i++])\n    }\n\n    const textPropName = options.propName.text || 'text'\n    // Join into 1 line, SSA-style linebreaks\n    // Strip out other SSA-style tags\n    sub[textPropName] = text.join(' ').replace(/\\{(\\\\[\\w]+\\(?([\\w\\d]+,?)+\\)?)+\\}/gi, '')\n\n    const x = 'asdf'\n\n    // Escape HTML entities\n    sub[textPropName] = sub[textPropName].replace(/</g, '&lt;').replace(/>/g, '&gt;')\n\n    // Unescape great than and less than when it makes a valid html tag of a supported style (font, b, u, s, i)\n    // Modified version of regex from Phil Haack's blog: http://haacked.com/archive/2004/10/25/usingregularexpressionstomatchhtml.aspx\n    // Later modified by kev: http://kevin.deldycke.com/2007/03/ultimate-regular-expression-for-html-tag-parsing-with-php/\n    sub[textPropName] = sub[textPropName].replace(/&lt;(\\/?(font|b|u|i|s))((\\s+(\\w|\\w[\\w\\-]*\\w)(\\s*=\\s*(?:\".*?\"|'.*?'|[^'\">\\s]+))?)+\\s*|\\s*)(\\/?)&gt;/gi, '<$1$3$7>')\n    \n    if (!options.ignoreLineBreaks) sub[textPropName] = sub[textPropName].replace(/\\\\N/gi, '<br />')\n    else sub[textPropName] = sub[textPropName].replace(/\\\\N/gi, '')\n\n    subs.push(sub)\n  }\n\n  return subs\n}\n"],"names":["toSeconds","time","t","split","s","length","parseFloat","e","nextNonEmptyLine","linesArray","position","idx","lastNonEmptyLine","parseSRT","data","options","propName","subs","lines","endIdx","text","sub","i","id","parseInt","start","timeInText","indexOf","substr","end","push","textPropName","join","replace","x","ignoreLineBreaks"],"mappings":"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"}